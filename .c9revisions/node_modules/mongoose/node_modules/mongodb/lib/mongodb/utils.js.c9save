{"ts":1369170028287,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Sort functions, Normalize and prepare sort parameters\n */\nvar formatSortValue = exports.formatSortValue = function(sortDirection) {\n  var value = (\"\" + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new Error(\"Illegal sort clause, must be of the form \"\n                    + \"[['field1', '(ascending|descending)'], \"\n                    + \"['field2', '(ascending|descending)']]\");\n  }\n};\n\nvar formattedOrderClause = exports.formattedOrderClause = function(sortValue) {\n  var orderBy = {};\n\n  if (Array.isArray(sortValue)) {\n    for(var i = 0; i < sortValue.length; i++) {\n      if(sortValue[i].constructor == String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }      \n    }\n  } else if(Object.prototype.toString.call(sortValue) === '[object Object]') {\n    orderBy = sortValue;\n  } else if (sortValue.constructor == String) {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error(\"Illegal sort clause, must be of the form \" +\n      \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n  }\n\n  return orderBy;\n};\n\nexports.encodeInt = function(value) {\n  var buffer = new Buffer(4);\n  buffer[3] = (value >> 24) & 0xff;      \n  buffer[2] = (value >> 16) & 0xff;\n  buffer[1] = (value >> 8) & 0xff;\n  buffer[0] = value & 0xff;\n  return buffer;\n}\n\nexports.encodeIntInPlace = function(value, buffer, index) {\n  buffer[index + 3] = (value >> 24) & 0xff;\t\t\t\n\tbuffer[index + 2] = (value >> 16) & 0xff;\n\tbuffer[index + 1] = (value >> 8) & 0xff;\n\tbuffer[index] = value & 0xff;\n}\n\nexports.encodeCString = function(string) {\n  var buf = new Buffer(string, 'utf8');\n  return [buf, new Buffer([0])];\n}\n\nexports.decodeUInt32 = function(array, index) {\n  return array[index] | array[index + 1] << 8 | array[index + 2] << 16 | array[index + 3] << 24;\n}\n\n// Decode the int\nexports.decodeUInt8 = function(array, index) {\n  return array[index];\n}\n\n/**\n * Context insensitive type checks\n */\n\nvar toString = Object.prototype.toString;\n\nexports.isObject = function (arg) {\n  return '[object Object]' == toString.call(arg)\n}\n\nexports.isArray = function (arg) {\n  return Array.isArray(arg) ||\n    'object' == typeof arg && '[object Array]' == toString.call(arg)\n}\n\nexports.isDate = function (arg) {\n  return 'object' == typeof arg && '[object Date]' == toString.call(arg)\n}\n\nexports.isRegExp = function (arg) {\n  return 'object' == typeof arg && '[object RegExp]' == toString.call(arg)\n}\n\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\nexports.toError = function(error) {\n  if (error instanceof Error) return error;\n\n  var msg = error.err || error.errmsg || error;\n  var e = new Error(msg);\n  e.name = 'MongoError';\n\n  // Get all object keys\n  var keys = typeof error == 'object'\n    ? Object.keys(error)\n    : [];\n\n  for(var i = 0; i < keys.length; i++) {\n    e[keys[i]] = error[keys[i]];\n  }\n\n  return e;\n}\n\n/**\n * Convert a single level object to an array\n * @ignore\n * @api private\n */\nexports.objectToArray = function(object) {\n  var list = [];\n\n  for(var name in object) {\n    list.push(object[name])\n  }\n\n  return list;\n}\n\n"]],"start1":0,"start2":0,"length1":0,"length2":3335}]],"length":3335}
